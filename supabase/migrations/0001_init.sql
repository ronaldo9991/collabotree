-- CollaboTree Database Schema
-- This migration creates the complete database schema for the CollaboTree platform

-- 0) ENUMS
do $$ begin
  if not exists (select 1 from pg_type where typname = 'order_type') then
    create type order_type as enum ('purchase','hire');
  end if;
  if not exists (select 1 from pg_type where typname = 'order_status') then
    create type order_status as enum ('pending','paid','accepted','cancelled','refunded');
  end if;
end $$;

-- 1) USERS (extends auth.users via auth_id)
create table public.users (
  id uuid primary key default gen_random_uuid(),
  auth_id uuid unique references auth.users(id) on delete cascade,
  full_name text not null,
  email text unique not null,
  role text not null check (role in ('student','buyer','admin')),
  created_at timestamptz default now()
);

-- 2) STUDENTS
create table public.students (
  id uuid primary key references public.users(id) on delete cascade,
  university text,
  skills text[],
  verified boolean default false,
  id_card_url text
);

-- 3) BUYERS
create table public.buyers (
  id uuid primary key references public.users(id) on delete cascade,
  company_name text,
  industry text,
  budget_range text
);

-- 4) PROJECTS
create table public.projects (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  description text,
  cover_url text,
  created_by uuid references public.users(id) on delete set null,
  owner_role text not null check (owner_role in ('student','buyer')),
  budget numeric,
  status text not null default 'open' check (status in ('open','in_progress','completed','archived')),
  tags text[],
  created_at timestamptz default now()
);

-- 5) APPLICATIONS (student -> project)
create table public.project_applications (
  id uuid primary key default gen_random_uuid(),
  project_id uuid references public.projects(id) on delete cascade,
  student_id uuid references public.students(id) on delete cascade,
  cover_letter text,
  bid_amount numeric,
  status text not null default 'pending' check (status in ('pending','accepted','rejected','withdrawn')),
  applied_at timestamptz default now(),
  unique (project_id, student_id)
);

-- 6) ASSIGNMENTS (accepted engagement)
create table public.project_assignments (
  id uuid primary key default gen_random_uuid(),
  project_id uuid unique references public.projects(id) on delete cascade,
  student_id uuid references public.students(id) on delete set null,
  buyer_id uuid references public.buyers(id) on delete set null,
  started_at timestamptz default now(),
  completed_at timestamptz
);

-- 7) ORDERS (for purchase/hire transactions)
create table public.orders (
  id uuid primary key default gen_random_uuid(),
  project_id uuid not null references public.projects(id) on delete cascade,
  buyer_id uuid not null references public.users(id) on delete cascade,
  seller_id uuid not null references public.users(id) on delete cascade,
  type order_type not null,
  status order_status not null default 'pending',
  amount_cents int not null,
  created_at timestamptz default now(),
  paid_at timestamptz
);

-- 8) CHAT_THREADS (one per order OR one per project+pair)
create table public.chat_threads (
  id uuid primary key default gen_random_uuid(),
  project_id uuid not null references public.projects(id) on delete cascade,
  buyer_id uuid not null references public.users(id) on delete cascade,
  seller_id uuid not null references public.users(id) on delete cascade,
  last_msg_at timestamptz,
  msg_count int not null default 0,
  created_at timestamptz default now(),
  unique (project_id, buyer_id, seller_id)
);

-- 9) CHAT_MESSAGES (hard cap per thread via trigger)
create table public.chat_messages (
  id bigint generated by default as identity primary key,
  thread_id uuid not null references public.chat_threads(id) on delete cascade,
  sender_id uuid not null references public.users(id) on delete cascade,
  body text not null,
  created_at timestamptz default now()
);

-- 10) READ RECEIPTS (optional + tiny)
create table public.chat_read_receipts (
  thread_id uuid references public.chat_threads(id) on delete cascade,
  user_id uuid references public.users(id) on delete cascade,
  last_read_at timestamptz not null,
  primary key (thread_id, user_id)
);

-- 11) ADMIN AUDIT
create table public.admin_actions (
  id uuid primary key default gen_random_uuid(),
  admin_id uuid references public.users(id) on delete set null,
  action text not null,
  target_user uuid references public.users(id),
  target_project uuid references public.projects(id),
  created_at timestamptz default now()
);

-- 12) INDEXES
create index on public.projects (status, created_at desc);
create index on public.project_applications (project_id, status);
create index on public.messages (project_id, created_at);
create index on public.orders (project_id, buyer_id, status);
create index on public.chat_threads (last_msg_at desc);
create index on public.chat_messages (thread_id, created_at);

-- 13) RLS
alter table public.users enable row level security;
alter table public.students enable row level security;
alter table public.buyers enable row level security;
alter table public.projects enable row level security;
alter table public.project_applications enable row level security;
alter table public.project_assignments enable row level security;
alter table public.orders enable row level security;
alter table public.chat_threads enable row level security;
alter table public.chat_messages enable row level security;
alter table public.chat_read_receipts enable row level security;
alter table public.admin_actions enable row level security;

-- 14) Helper function: current user id
create or replace function public.uid() returns uuid
language sql stable as $$
  select auth.uid()
$$;

-- 15) POLICIES
-- users: user sees self; admin sees all
create policy "users_self_select" on public.users
for select using (id = public.uid() or exists (select 1 from public.users u where u.id = public.uid() and u.role = 'admin'));

create policy "users_self_update" on public.users
for update using (id = public.uid());

-- students: only owner; admin sees all
create policy "students_self_select" on public.students
for select using (id = public.uid() or exists (select 1 from public.users u where u.id = public.uid() and u.role='admin'));
create policy "students_self_upd" on public.students
for update using (id = public.uid());

-- buyers: only owner; admin sees all
create policy "buyers_self_select" on public.buyers
for select using (id = public.uid() or exists (select 1 from public.users u where u.id = public.uid() and u.role='admin'));
create policy "buyers_self_upd" on public.buyers
for update using (id = public.uid());

-- projects:
-- creator can CRUD; everyone can select 'open' for Explore; admin full
create policy "projects_public_explore" on public.projects
for select using (status = 'open' or exists (select 1 from public.users u where u.id = public.uid() and u.role='admin'));
create policy "projects_owner_write" on public.projects
for all using (created_by = public.uid()) with check (created_by = public.uid());

-- applications:
-- student owner read/write own application; project owner can read; admin full
create policy "apps_student_rw" on public.project_applications
for all using (student_id = public.uid()) with check (student_id = public.uid());

create policy "apps_project_owner_read" on public.project_applications
for select using (
  exists (
    select 1 from public.projects p
    where p.id = project_id and p.created_by = public.uid()
  )
);

-- assignments:
-- visible to involved parties; admin full
create policy "assign_view" on public.project_assignments
for select using (
  exists (select 1 from public.users u where u.id = public.uid() and u.role='admin')
  or exists (select 1 from public.students s where s.id = public.uid() and s.id = student_id)
  or exists (select 1 from public.buyers b where b.id = public.uid() and b.id = buyer_id)
);

-- orders: visible to buyer/seller/admin
create policy "orders_party_read" on public.orders
for select using (
  buyer_id = public.uid() or seller_id = public.uid() or
  exists (select 1 from public.users u where u.id = public.uid() and u.role='admin')
);

-- chat threads: only the buyer or seller (student) or admin
create policy "threads_party_rw" on public.chat_threads
for all using (
  buyer_id = public.uid() or seller_id = public.uid() or
  exists (select 1 from public.users u where u.id = public.uid() and u.role='admin')
) with check (
  buyer_id = public.uid() or seller_id = public.uid() or
  exists (select 1 from public.users u where u.id = public.uid() and u.role='admin')
);

-- messages: only members of thread can read/write
create policy "msgs_party_rw" on public.chat_messages
for all using (
  exists (select 1 from public.chat_threads t where t.id = thread_id and (t.buyer_id = public.uid() or t.seller_id = public.uid()))
) with check (
  exists (select 1 from public.chat_threads t where t.id = thread_id and (t.buyer_id = public.uid() or t.seller_id = public.uid()))
);

-- receipts: only own row per thread
create policy "receipts_self_rw" on public.chat_read_receipts
for all using (user_id = public.uid()) with check (user_id = public.uid());

-- admin_actions: admin only
create policy "admin_rw" on public.admin_actions
for all using (exists (select 1 from public.users u where u.id = public.uid() and u.role='admin'))
with check (exists (select 1 from public.users u where u.id = public.uid() and u.role='admin'));

-- 16) Chat configuration and triggers for message limits
create table public.chat_config (
  id boolean primary key default true,
  max_msgs_per_thread int not null default 500,
  max_msg_bytes int not null default 2000
);
insert into public.chat_config (id) values (true) on conflict (id) do nothing;

-- Enforce message length
create or replace function public.enforce_msg_len() returns trigger as $$
begin
  if octet_length(new.body) > (select max_msg_bytes from public.chat_config where id = true) then
    raise exception 'Message too long';
  end if;
  return new;
end $$ language plpgsql;

create trigger trg_msg_len before insert on public.chat_messages
for each row execute function public.enforce_msg_len();

-- Increment counters & roll-off
create or replace function public.on_message_insert() returns trigger as $$
declare
  cap int;
  extra int;
begin
  update public.chat_threads
    set last_msg_at = now(), msg_count = msg_count + 1
  where id = new.thread_id;

  select max_msgs_per_thread into cap from public.chat_config where id = true;

  -- If over cap, move oldest overflow messages to storage (via queue) and delete
  perform 1 from public.chat_messages where thread_id = new.thread_id;
  select greatest((select count(*) from public.chat_messages where thread_id=new.thread_id) - cap, 0) into extra;

  if extra > 0 then
    -- queue archival (lightweight): insert rows to a small queue table
    insert into public.archive_queue(thread_id, limit_to_archive)
    values (new.thread_id, extra)
    on conflict do nothing;
  end if;

  return new;
end $$ language plpgsql;

create trigger trg_msg_insert after insert on public.chat_messages
for each row execute function public.on_message_insert();

-- Archival queue & worker function
create table public.archive_queue (
  thread_id uuid primary key,
  limit_to_archive int not null,
  created_at timestamptz default now()
);

-- Function to open chat after order
create or replace function public.open_chat_after_order(_order_id uuid) returns uuid
language plpgsql security definer as $$
declare
  o public.orders%rowtype;
  tid uuid;
begin
  select * into o from public.orders where id=_order_id;
  if not found then raise exception 'Order not found'; end if;

  if o.status not in ('paid','accepted') then
    raise exception 'Chat opens only after payment/accept';
  end if;

  insert into public.chat_threads (project_id, buyer_id, seller_id)
  values (o.project_id, o.buyer_id, o.seller_id)
  on conflict (project_id, buyer_id, seller_id)
  do update set project_id = excluded.project_id
  returning id into tid;

  return tid;
end $$;
