-- Fixed CollaboTree Database Schema
-- This fixes the bug in the original migration

-- 0) ENUMS
do $$ begin
  if not exists (select 1 from pg_type where typname = 'order_type') then
    create type order_type as enum ('purchase','hire');
  end if;
  if not exists (select 1 from pg_type where typname = 'order_status') then
    create type order_status as enum ('pending','paid','accepted','cancelled','refunded');
  end if;
end $$;

-- 1) USERS (extends auth.users via auth_id)
create table public.users (
  id uuid primary key default gen_random_uuid(),
  auth_id uuid unique references auth.users(id) on delete cascade,
  full_name text not null,
  email text unique not null,
  role text not null check (role in ('student','buyer','admin')),
  created_at timestamptz default now()
);

-- 2) STUDENTS
create table public.students (
  id uuid primary key references public.users(id) on delete cascade,
  university text,
  skills text[],
  verified boolean default false,
  id_card_url text
);

-- 3) BUYERS
create table public.buyers (
  id uuid primary key references public.users(id) on delete cascade,
  company_name text,
  industry text,
  budget_range text
);

-- 4) PROJECTS
create table public.projects (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  description text,
  cover_url text,
  created_by uuid references public.users(id) on delete set null,
  owner_role text not null check (owner_role in ('student','buyer')),
  budget numeric,
  status text not null default 'open' check (status in ('open','in_progress','completed','archived')),
  tags text[],
  created_at timestamptz default now()
);

-- 5) APPLICATIONS (student -> project)
create table public.project_applications (
  id uuid primary key default gen_random_uuid(),
  project_id uuid references public.projects(id) on delete cascade,
  student_id uuid references public.students(id) on delete cascade,
  cover_letter text,
  bid_amount numeric,
  status text not null default 'pending' check (status in ('pending','accepted','rejected','withdrawn')),
  applied_at timestamptz default now(),
  unique (project_id, student_id)
);

-- 6) ASSIGNMENTS (accepted engagement)
create table public.project_assignments (
  id uuid primary key default gen_random_uuid(),
  project_id uuid unique references public.projects(id) on delete cascade,
  student_id uuid references public.students(id) on delete set null,
  buyer_id uuid references public.buyers(id) on delete set null,
  started_at timestamptz default now(),
  completed_at timestamptz
);

-- 7) ORDERS (for purchase/hire transactions)
create table public.orders (
  id uuid primary key default gen_random_uuid(),
  project_id uuid not null references public.projects(id) on delete cascade,
  buyer_id uuid not null references public.users(id) on delete cascade,
  seller_id uuid not null references public.users(id) on delete cascade,
  type order_type not null,
  status order_status not null default 'pending',
  amount_cents int not null,
  created_at timestamptz default now(),
  paid_at timestamptz
);

-- 8) CHAT_THREADS (one per order OR one per project+pair)
create table public.chat_threads (
  id uuid primary key default gen_random_uuid(),
  project_id uuid not null references public.projects(id) on delete cascade,
  buyer_id uuid not null references public.users(id) on delete cascade,
  seller_id uuid not null references public.users(id) on delete cascade,
  last_msg_at timestamptz,
  msg_count int not null default 0,
  created_at timestamptz default now(),
  unique (project_id, buyer_id, seller_id)
);

-- 9) CHAT_MESSAGES (hard cap per thread via trigger)
create table public.chat_messages (
  id bigint generated by default as identity primary key,
  thread_id uuid not null references public.chat_threads(id) on delete cascade,
  sender_id uuid not null references public.users(id) on delete cascade,
  body text not null,
  created_at timestamptz default now()
);

-- 10) READ RECEIPTS (optional + tiny)
create table public.chat_read_receipts (
  thread_id uuid references public.chat_threads(id) on delete cascade,
  user_id uuid references public.users(id) on delete cascade,
  last_read_at timestamptz not null,
  primary key (thread_id, user_id)
);

-- 11) ADMIN AUDIT
create table public.admin_actions (
  id uuid primary key default gen_random_uuid(),
  admin_id uuid references public.users(id) on delete set null,
  action text not null,
  target_user uuid references public.users(id),
  target_project uuid references public.projects(id),
  created_at timestamptz default now()
);

-- 12) INDEXES (FIXED: changed public.messages to public.chat_messages)
create index on public.projects (status, created_at desc);
create index on public.project_applications (project_id, status);
create index on public.chat_messages (thread_id, created_at);
create index on public.orders (project_id, buyer_id, status);
create index on public.chat_threads (last_msg_at desc);

-- 13) RLS
alter table public.users enable row level security;
alter table public.students enable row level security;
alter table public.buyers enable row level security;
alter table public.projects enable row level security;
alter table public.project_applications enable row level security;
alter table public.project_assignments enable row level security;
alter table public.orders enable row level security;
alter table public.chat_threads enable row level security;
alter table public.chat_messages enable row level security;
alter table public.chat_read_receipts enable row level security;
alter table public.admin_actions enable row level security;

-- 14) Helper function: current user id
create or replace function public.uid() returns uuid
language sql stable as $$
  select auth.uid()
$$;

-- 15) BASIC POLICIES (simplified for now)
-- users: user sees self
create policy "users_self_select" on public.users
for select using (id = public.uid());

create policy "users_self_update" on public.users
for update using (id = public.uid());

-- students: only owner
create policy "students_self_select" on public.students
for select using (id = public.uid());
create policy "students_self_upd" on public.students
for update using (id = public.uid());

-- buyers: only owner
create policy "buyers_self_select" on public.buyers
for select using (id = public.uid());
create policy "buyers_self_upd" on public.buyers
for update using (id = public.uid());

-- projects: public for viewing, owner can write
create policy "projects_public_explore" on public.projects
for select using (true);
create policy "projects_owner_write" on public.projects
for all using (created_by = public.uid()) with check (created_by = public.uid());

-- applications: student owner read/write
create policy "apps_student_rw" on public.project_applications
for all using (student_id = public.uid()) with check (student_id = public.uid());

-- orders: visible to buyer/seller
create policy "orders_party_read" on public.orders
for select using (
  buyer_id = public.uid() or seller_id = public.uid()
);

-- chat threads: only the buyer or seller
create policy "threads_party_rw" on public.chat_threads
for all using (
  buyer_id = public.uid() or seller_id = public.uid()
) with check (
  buyer_id = public.uid() or seller_id = public.uid()
);

-- messages: only members of thread can read/write
create policy "msgs_party_rw" on public.chat_messages
for all using (
  exists (select 1 from public.chat_threads t where t.id = thread_id and (t.buyer_id = public.uid() or t.seller_id = public.uid()))
) with check (
  exists (select 1 from public.chat_threads t where t.id = thread_id and (t.buyer_id = public.uid() or t.seller_id = public.uid()))
);

-- receipts: only own row per thread
create policy "receipts_self_rw" on public.chat_read_receipts
for all using (user_id = public.uid()) with check (user_id = public.uid());

-- Success message
SELECT 'Fixed database schema created successfully!' as message;
